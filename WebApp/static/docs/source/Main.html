<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-dirac-views-desktop-Main'>/**
</span> * @class Ext.dirac.views.desktop.Main
 * @extends Ext.panel.Panel
 * 
 * This class manages the wallpaper, shortcuts, taskbar, desktop states, and the
 * broadcast part for the window states.
 * 
 */

Ext.define(&#39;Ext.dirac.views.desktop.Main&#39;, {
  extend : &#39;Ext.panel.Panel&#39;,
  alias : &#39;widget.desktop&#39;,
  requires : [&#39;Ext.util.MixedCollection&#39;, &#39;Ext.menu.Menu&#39;, &#39;Ext.view.View&#39;, &#39;Ext.dirac.views.desktop.Window&#39;, &#39;Ext.dirac.views.desktop.TaskBar&#39;, &#39;Ext.dirac.views.desktop.Wallpaper&#39;, &#39;Ext.dirac.views.desktop.StateManagement&#39;, &#39;Ext.dirac.views.desktop.ShortcutModel&#39;],
  mixins : [&quot;Ext.dirac.core.Stateful&quot;, &quot;Ext.dirac.core.AppView&quot;, &quot;Ext.dirac.views.desktop.TransformationData&quot;],

<span id='Ext-dirac-views-desktop-Main-property-activeWindowCls'>  activeWindowCls : &#39;ux-desktop-active-win&#39;,
</span><span id='Ext-dirac-views-desktop-Main-property-inactiveWindowCls'>  inactiveWindowCls : &#39;ux-desktop-inactive-win&#39;,
</span><span id='Ext-dirac-views-desktop-Main-property-lastActiveWindow'>  lastActiveWindow : null,
</span>
<span id='Ext-dirac-views-desktop-Main-property-border'>  border : false,
</span><span id='Ext-dirac-views-desktop-Main-property-html'>  html : &#39;&amp;#160;&#39;,
</span><span id='Ext-dirac-views-desktop-Main-property-layout'>  layout : &#39;fit&#39;,
</span><span id='Ext-dirac-views-desktop-Main-property-xTickSize'>  xTickSize : 1,
</span><span id='Ext-dirac-views-desktop-Main-property-yTickSize'>  yTickSize : 1,
</span><span id='Ext-dirac-views-desktop-Main-property-registerStartMenus'>  registerStartMenus : {},
</span>
<span id='Ext-dirac-views-desktop-Main-property-windowMenu'>  /**
</span>   * @property {Ext.menu.Menu} windowMenu Menu that is used as a context menu
   *           that appears when a window is clicked within the taskbar
   */
  windowMenu : null,

<span id='Ext-dirac-views-desktop-Main-property-windows'>  /**
</span>   * @property {Ext.util.MixedCollection} windows This is the collection of
   *           created windows (available on the taskbar)
   */
  windows : null,

<span id='Ext-dirac-views-desktop-Main-property-contextMenu'>  /**
</span>   * @property {Ext.menu.Menu} contextMenu Menu that is used as a context menu
   *           for the desktop
   */
  contextMenu : null,

<span id='Ext-dirac-views-desktop-Main-cfg-shortcuts'>  /**
</span>   * @cfg {Array | Store} shortcuts The items to add to the DataView. This can
   *      be a {@link Ext.data.Store Store} or a simple array. Items should
   *      minimally provide the fields in the
   *      {@link Ext.dirac.views.desktop.ShorcutModel ShortcutModel}.
   */
  shortcuts : null,

<span id='Ext-dirac-views-desktop-Main-cfg-shortcutItemSelector'>  /**
</span>   * @cfg {String} shortcutItemSelector This property is passed to the DataView
   *      for the desktop to select shortcut items. If the {@link #shortcutTpl}
   *      is modified, this will probably need to be modified as well.
   */
  shortcutItemSelector : &#39;div.ux-desktop-shortcut&#39;,

<span id='Ext-dirac-views-desktop-Main-cfg-shortcutTpl'>  /**
</span>   * @cfg {String} shortcutTpl This XTemplate is used to render items in the
   *      DataView. If this is changed, the {@link shortcutItemSelect} will
   *      probably also need to changed.
   */
  shortcutTpl : [&#39;&lt;tpl for=&quot;.&quot;&gt;&#39;, &#39;&lt;div class=&quot;ux-desktop-shortcut&quot; id=&quot;{name}-shortcut&quot;&gt;&#39;, &#39;&lt;div class=&quot;ux-desktop-shortcut-icon {iconCls}&quot;&gt;&#39;, &#39;&lt;img src=&quot;&#39;, Ext.BLANK_IMAGE_URL, &#39;&quot; title=&quot;{name}&quot;&gt;&#39;, &#39;&lt;/div&gt;&#39;, &#39;&lt;span class=&quot;ux-desktop-shortcut-text&quot;&gt;{name}&lt;/span&gt;&#39;, &#39;&lt;/div&gt;&#39;,
      &#39;&lt;/tpl&gt;&#39;, &#39;&lt;div class=&quot;x-clear&quot;&gt;&lt;/div&gt;&#39;],
<span id='Ext-dirac-views-desktop-Main-cfg-taskbarConfig'>  /**
</span>   * @cfg {Object} taskbarConfig The config object for the
   *      TaskBar.http://www.youtube.com/
   */
  taskbarConfig : null,

<span id='Ext-dirac-views-desktop-Main-cfg-desktopGranularity'>  /**
</span>   * @cfg {Array} desktopGranularity Defines the dimension of the matrix used
   *      for pinning apps
   */
  desktopGranularity : [12, 12],

<span id='Ext-dirac-views-desktop-Main-property-stateDataStructureVersion'>  stateDataStructureVersion : 1,
</span>
<span id='Ext-dirac-views-desktop-Main-property-wallpaper'>  wallpaper : GLOBAL.ROOT_URL + &#39;static/core/img/wallpapers/dirac_background_6.png&#39;,
</span>
<span id='Ext-dirac-views-desktop-Main-property-wallpaperStretch'>  wallpaperStretch : false,
</span>
<span id='Ext-dirac-views-desktop-Main-method-getStateData'>  getStateData : function() {
</span>
    var me = this;

    var oData = {
      &quot;dirac_view&quot; : 1,
      &quot;version&quot; : GLOBAL.MAIN_VIEW_SAVE_STRUCTURE_VERSION,
      &quot;data&quot; : [],
      &quot;views&quot; : {
        &quot;desktop&quot; : {
          &quot;version&quot; : me.stateDataStructureVersion,
          &quot;desktopGranularity&quot; : me.desktopGranularity,
          &quot;positions&quot; : []
        }
      }
    };

    me.windows.each(function(win) {

          /*
           * First we check whether the window is not a child window
           */

          if (!win.isChildWindow) {

            /*
             * Depends on the loadedObjectType
             */
            var oElem = null;

            if (win.loadedObjectType == &quot;app&quot;) {

              var item = {
                module : win.getAppClassName(),
                data : win.loadedObject.getStateData(),
                currentState : win.currentState,
                loadedObjectType : win.loadedObjectType
              }
              if (win.childWindows.length &gt; 0) {
                for (var i = 0; i &lt; win.childWindows.length; i++) {
                  if (win.childWindows[i].isChildWindow &amp;&amp; win.childWindows[i].type == &quot;help&quot;) {
                    var helptext = {
                      &quot;helptext&quot; : win.childWindows[i].items.getAt(0).getValue()
                    };
                    Ext.apply(item.data, helptext);
                  }
                }
              } else {
                Ext.apply(item.data, win.loadedObject.getHelpText());
              }
              oData.data.push(item);

              oData.views.desktop.positions.push({
                    x : win.x,
                    y : win.y,
                    width : win.getWidth(),
                    height : win.getHeight(),
                    maximized : win.maximized,
                    minimized : win.minimized,
                    zIndex : win.zIndex,
                    loadedObjectType : win.loadedObjectType,
                    desktopStickMode : ((win.desktopStickMode) ? 1 : 0),
                    headerHidden : ((win.getHeader().hidden) ? 1 : 0),
                    i_x : win.i_x,
                    i_y : win.i_y,
                    ic_x : win.ic_x,
                    ic_y : win.ic_y,
                    _before_pin_state : win._before_pin_state
                  });

            } else if (win.loadedObjectType == &quot;link&quot;) {

              oData.data.push({
                    link : win.linkToLoad
                  });

              oData.views.desktop.positions.push({
                    title : win.title,
                    x : win.x,
                    y : win.y,
                    width : win.getWidth(),
                    height : win.getHeight(),
                    maximized : win.maximized,
                    minimized : win.minimized,
                    zIndex : win.zIndex,
                    loadedObjectType : win.loadedObjectType,
                    desktopStickMode : ((win.desktopStickMode) ? 1 : 0),
                    headerHidden : ((win.getHeader().hidden) ? 1 : 0),
                    i_x : win.i_x,
                    i_y : win.i_y,
                    ic_x : win.ic_x,
                    ic_y : win.ic_y,
                    _before_pin_state : win._before_pin_state
                  });

            }

          }

        });

    return oData;

  },

<span id='Ext-dirac-views-desktop-Main-method-loadState'>  loadState : function(oData) {
</span>
    var me = this;

    if (me.ID in oData[&quot;views&quot;]) {
      /*
       * The case when the the views.desktop does not exists has to be supported !
       */
      me.desktopGranularity = oData[&quot;views&quot;][&quot;desktop&quot;][&quot;desktopGranularity&quot;];

      me.takenCells = [];

      for (var i = 0; i &lt; me.desktopGranularity[0]; i++) {

        me.takenCells.push([]);

        for (var j = 0; j &lt; me.desktopGranularity[1]; j++) {

          me.takenCells[i].push(false);

        }

      }

      var iWidth = me.getWidth();
      var iHeight = me.getHeight() - me.taskbar.getHeight();

      me.boxSizeX = 1.0 * iWidth / me.desktopGranularity[1];
      me.boxSizeY = 1.0 * iHeight / me.desktopGranularity[0];

      for (var i = 0, len = oData[&quot;views&quot;][&quot;desktop&quot;][&quot;positions&quot;].length; i &lt; len; i++) {

        var oAppStateData = oData[&quot;views&quot;][&quot;desktop&quot;][&quot;positions&quot;][i];

        if (&quot;module&quot; in oData[&quot;data&quot;][i]) {

          oAppStateData.name = oData[&quot;data&quot;][i].module;
          oAppStateData.data = oData[&quot;data&quot;][i].data;
          oAppStateData.currentState = oData[&quot;data&quot;][i].currentState;
          me.createWindow(oAppStateData.loadedObjectType, oAppStateData.name, oAppStateData);
        }
      }
    } else {

      // we have to clean the takenCells matrix
      me.setDesktopMatrixCells(0, me.desktopGranularity[0] - 1, 0, me.desktopGranularity[1] - 1, false);

      for (var i = 0, len = oData[&quot;data&quot;].length; i &lt; len; i++) {

        if (&quot;module&quot; in oData[&quot;data&quot;][i]) {

          var oAppStateData = {};

          oAppStateData.name = oData[&quot;data&quot;][i].module;
          oAppStateData.data = oData[&quot;data&quot;][i].data;
          oAppStateData.currentState = oData[&quot;data&quot;][i].currentState;

          me.createWindow(&quot;app&quot;, oAppStateData.name, oAppStateData);
        }
      }

    }

  },

<span id='Ext-dirac-views-desktop-Main-method-initComponent'>  initComponent : function() {
</span>    var me = this;

    me.ID = &quot;desktop&quot;;

    // the width of a desktop cell used for pinning
    me.boxSizeX = 0;
    // the height of a desktop cell used for pinning
    me.boxSizeY = 0;

    /*
     * The taskbar object has a taskbar and a menu that appears when we right
     * click on a task within the taskbar
     */
    me.windowMenu = new Ext.menu.Menu(me.createWindowMenu());

    me.SM = new Ext.dirac.views.desktop.StateManagement();
    me.bbar = me.taskbar = new Ext.dirac.views.desktop.TaskBar(me.taskbarConfig);
    me.taskbar.windowMenu = me.windowMenu;

    /*
     * Collection of windows
     */
    me.windows = new Ext.util.MixedCollection();

    /*
     * There is another menu the one that appears when we click somewhere on the
     * desktop
     */
    me.contextMenu = new Ext.menu.Menu(me.createDesktopMenu());

    me.shortcuts = Ext.create(&#39;Ext.data.Store&#39;, {
          model : &#39;Ext.dirac.views.desktop.ShortcutModel&#39;,
          data : {}
        });

    me.contextMenuItems = [];

    me.items = [{
          xtype : &#39;wallpaper&#39;,
          id : me.id + &#39;_wallpaper&#39;
        }, me.createDataView()];

    me.callParent(arguments);

    /*
     * Setting the wallpaper
     */

    var wallpaper = me.wallpaper;
    me.wallpaper = me.items.getAt(0);
    if (wallpaper) {
      me.setWallpaper(wallpaper, me.wallpaperStretch);
    }

    // the matrix that registers what cells from the desktop are
    // taken and what are not
    me.takenCells = [];

    for (var i = 0; i &lt; me.desktopGranularity[0]; i++) {

      me.takenCells.push([]);

      for (var j = 0; j &lt; me.desktopGranularity[1]; j++) {

        me.takenCells[i].push(false);

      }

    }

    me._state_related_url = &quot;&quot;;

    me.TD = new Ext.dirac.views.desktop.TransformationData();

  },

<span id='Ext-dirac-views-desktop-Main-method-afterRender'>  /**
</span>   * @private method executed after the desktop has been rendered
   */
  afterRender : function() {
    var me = this;
    me.callParent();
    me.el.on(&#39;contextmenu&#39;, me.onDesktopMenu, me);

    // load the state of the desktop described in the URL
    me.__oprLoadUrlState();

  },

<span id='Ext-dirac-views-desktop-Main-property-listeners'>  listeners : {
</span>
<span id='Ext-dirac-views-desktop-Main-method-resize'>    /**
</span>     * @private Resize event handler. All existing windows are being resized.
     */
    resize : function(oComp, w, h, ow, oh, eOpts) {

      var me = oComp;

      var iWidth = me.getWidth();
      var iHeight = me.getHeight() - me.taskbar.getHeight();

      // we calculate the new dimensions of the cells
      me.boxSizeX = 1.0 * iWidth / me.desktopGranularity[1];
      me.boxSizeY = 1.0 * iHeight / me.desktopGranularity[0];

      // we resize each window, which is pinned
      me.windows.each(function(win) {
            if (win.desktopStickMode) {

              var oPos = [0, 0];

              oPos[0] = Math.round(win.i_x * me.boxSizeX);
              oPos[1] = Math.round(win.i_y * me.boxSizeY);

              win._x = oPos[0];
              win._y = oPos[1];

              win.suspendEvent(&quot;resize&quot;);
              win.suspendEvent(&quot;move&quot;);
              win.setPosition(oPos[0], oPos[1]);
              win.setSize(Math.round(me.boxSizeX * win.ic_x), Math.round(me.boxSizeY * win.ic_y));
              win.resumeEvent(&quot;resize&quot;);
              win.resumeEvent(&quot;move&quot;);

            } else {

              var ratioWidth = 1.0 * w / ow;
              var ratioHeight = 1.0 * h / oh;

              var oPos = [0, 0];

              oPos[0] = Math.round(ratioWidth * win.x);
              oPos[1] = Math.round(ratioHeight * win.y);

              win.suspendEvent(&quot;resize&quot;);
              win.suspendEvent(&quot;move&quot;);
              win.setPosition(oPos[0], oPos[1]);
              win.setSize(Math.round(ratioWidth * win.width), Math.round(ratioHeight * win.height));
              win.resumeEvent(&quot;resize&quot;);
              win.resumeEvent(&quot;move&quot;);

            }
          });

    }

  },

<span id='Ext-dirac-views-desktop-Main-method-__oprLoadUrlState'>  /**
</span>   * @private Method called to load the state of the desktop described in the
   *          URL. This method is called after the desktop has been rendered.
   */
  __oprLoadUrlState : function() {

    var me = this;

    var oValid = true;

    if (GLOBAL.OPEN_APP != &quot;&quot;) {

      me.createWindow(&quot;app&quot;, GLOBAL.OPEN_APP, {
            maximized : true
          });

      return;
    }

    GLOBAL.URL_STATE = Ext.util.Format.trim(GLOBAL.URL_STATE);

    // if the URL state is not empty
    if (GLOBAL.URL_STATE.length != &quot;&quot;) {

      // we get two parts of the URL state
      var oParts = GLOBAL.URL_STATE.split(&quot;|&quot;);

      // if the number of parts differ from 2, it means that it is
      // a mistake
      if (oParts.length != 2) {

        me.refreshUrlDesktopState();
        return;

      }

      // if the indicator for desktop loaded state is not valid
      if ((parseInt(oParts[0], 10) != 0) &amp;&amp; (parseInt(oParts[0], 10) != 1)) {

        oValid = false;

      }

      /*
       * if the indicator for desktop loaded state is 0, it means that no
       * desktop state has been loaded, but only particular apps
       */
      if (parseInt(oParts[0], 10) == 0) {

        var oApps = oParts[1].split(&quot;^&quot;);

        // for each application in the URL state
        for (var i = 0; i &lt; oApps.length; i++) {

          var oAppParts = oApps[i].split(&quot;:&quot;);

          /*
           * for each application there must be 8 data describing their state
           * Each application is described with 8 parameters [A:B:C:D:E:F:G:H] A -
           * the name of the main app class B - the name of a state. If no state
           * is loaded then B is empty C - X position at the desktop D - Y
           * position at the desktop E - Width of the window F - Height of the
           * window G - Indicator whether the app is in minimized state (-1),
           * maximized state (1). 0 otherwise. H - [P1,P2,P3,P4,P5,P6] P1 - 0 if
           * the app is pinned; 1 if the app is pinned P2 - 0 if the header is
           * visible; 1 if the header is hidden P3 - X matrix index if the app
           * is pinned P4 - Y matrix index if the app is pinned P5 - Number of
           * cells regarding the X axis the app takes P6 - Number of cells
           * regarding the Y axis the app takes
           */
          if (oAppParts.length != 8) {

            oValid = false;
            break;

          }

          /*
           * if the application is valid i.e. it can be accessed by the user and
           * the other data are valid
           */
          if (!GLOBAL.APP.isValidApplication(oAppParts[0]) || isNaN(parseInt(oAppParts[2], 10)) || isNaN(parseInt(oAppParts[3], 10)) || isNaN(parseInt(oAppParts[4], 10)) || isNaN(parseInt(oAppParts[5], 10)) || isNaN(parseInt(oAppParts[6], 10))) {

            oValid = false;
            break;

          }

        }

      }

      // in the case of loaded desktop state, we check whether a
      // name of the desktop state exists
      if (parseInt(oParts[0], 10) == 1) {

        if (Ext.util.Format.trim(oParts[1]) == &quot;&quot;) {

          oValid = false;

        }

      }

    }

    if (oValid) {

      var oParts = GLOBAL.URL_STATE.split(&quot;|&quot;);

      if ((oParts.length != 2) || (Ext.util.Format.trim(oParts[1]).length == 0))
        return;

      if (parseInt(oParts[0], 10) == 0) {
        // non desktop state
        var oApps = oParts[1].split(&quot;^&quot;);

        for (var i = 0, len = oApps.length; i &lt; len; i++) {

          /*
           * For each application we prepare the data before we load into a
           * window.
           */
          var oAppItems = oApps[i].split(&quot;:&quot;);

          var oSetupData = {};

          if (Ext.util.Format.trim(oAppItems[1]) != &quot;&quot;)
            oSetupData.stateToLoad = oAppItems[1];

          oSetupData.x = oAppItems[2];
          oSetupData.y = oAppItems[3];
          oSetupData.width = oAppItems[4];
          oSetupData.height = oAppItems[5];

          var oPinnedData = oAppItems[7].split(&quot;,&quot;);
          oSetupData.desktopStickMode = parseInt(oPinnedData[0], 10);
          oSetupData.hiddenHeader = parseInt(oPinnedData[1], 10);
          oSetupData.i_x = parseInt(oPinnedData[2], 10);
          oSetupData.i_y = parseInt(oPinnedData[3], 10);
          oSetupData.ic_x = parseInt(oPinnedData[4], 10);
          oSetupData.ic_y = parseInt(oPinnedData[5], 10);

          switch (Ext.util.Format.trim(oAppItems[6])) {

            case &quot;1&quot; :
              oSetupData.maximized = true;
              break;
            case &quot;-1&quot; :
              oSetupData.minimized = true;
              break;

          }

          me.createWindow(&quot;app&quot;, oAppItems[0], oSetupData);

        }

      } else {
        // desktop state
        me.oprLoadDesktopState(oParts[1]);
      }

    } else {

      // if the data are not valid, we refresh the URL in the
      // browser
      me.refreshUrlDesktopState();

    }

  },

<span id='Ext-dirac-views-desktop-Main-method-createDataView'>  /**
</span>   * Overridable configuration method for the shortcuts presented on the desktop
   * 
   * @return Object
   */
  createDataView : function() {
    var me = this;
    return {
      xtype : &#39;dataview&#39;,
      overItemCls : &#39;x-view-over&#39;,
      trackOver : true,
      itemSelector : me.shortcutItemSelector,
      store : me.shortcuts,
      style : {
        position : &#39;absolute&#39;
      },
      x : 0,
      y : 0,
      tpl : new Ext.XTemplate(me.shortcutTpl)
    };
  },

<span id='Ext-dirac-views-desktop-Main-method-createDesktopMenu'>  /**
</span>   * Overridable configuration method for the desktop context menu (contextMenu)
   * 
   * @return Object
   */
  createDesktopMenu : function() {
    var me = this, ret = {
      items : me.contextMenuItems || []
    };

    // reading the existing states of the desktop for that user
    me.statesMenu = new Ext.menu.Menu();

    var oFunc = function(iCode, sAppName) {
      me.oprReadDesktopStatesFromCache();
    };

    /*
     * if the state management is enabled, first we read the states and the
     * references and then we load them into the desktop menu.
     */

    if (GLOBAL.STATE_MANAGEMENT_ENABLED)
      GLOBAL.APP.SM.oprReadApplicationStatesAndReferences(&quot;desktop&quot;, oFunc);// OK

    /*
     * Function that is executed after a state has been saved
     */
    var funcAfterSave = function(iCode, sAppName, sStateType, sStateName) {

      if ((iCode == 1) &amp;&amp; (me.currentState != sStateName)) {

        // we create new item
        var oNewItem = Ext.create(&#39;Ext.menu.Item&#39;, {
              text : sStateName,
              handler : Ext.bind(me.oprLoadDesktopState, me, [sStateName], false),
              scope : me,
              iconCls : &quot;dirac-icon-state&quot;,
              minWidth : 200,
              menu : [{
                    text : &quot;Share state&quot;,
                    stateName : sStateName,
                    handler : function() {

                      var oThisItem = this;

                      GLOBAL.APP.SM.oprShareState(&quot;desktop&quot;, oThisItem.stateName, function(rCode, rAppName, rStateName, rMessage) {

                            if (rCode == 1) {

                              var oHtml = &quot;&quot;;
                              oHtml += &quot;&lt;div style=&#39;padding:5px&#39;&gt;The string you can send is as follows:&lt;/div&gt;&quot;;
                              oHtml += &quot;&lt;div style=&#39;padding:5px;font-weight:bold&#39;&gt;&quot; + rMessage + &quot;&lt;/div&gt;&quot;;

                              Ext.MessageBox.alert(&quot;Info for sharing the &lt;span style=&#39;color:red&#39;&gt;&quot; + rStateName + &quot;&lt;/span&gt; state:&quot;, oHtml);

                            }

                          });

                    },
                    iconCls : &quot;dirac-icon-share&quot;
                  }, {
                    text : &quot;Make public&quot;,
                    stateName : sStateName,
                    handler : function() {

                      var oThisItem = this;

                      GLOBAL.APP.SM.oprPublishState(&quot;desktop&quot;, oThisItem.stateName);

                    },
                    iconCls : &quot;dirac-icon-share&quot;
                  }]
            });

        // and we insert at the beginning of the menu
        me.statesMenu.insert(0, oNewItem);

        // if there is an active desktop state, we have to remove it
        if (me.currentState != &quot;&quot;)
          GLOBAL.APP.SM.oprRemoveActiveState(&quot;desktop&quot;, me.currentState);// OK

        // if there is a state, we set it as an active state
        me.currentState = sStateName;
        GLOBAL.APP.SM.oprAddActiveState(sAppName, sStateName);// OK
        me.refreshUrlDesktopState();

        if (me.SM.saveWindow)
          me.SM.saveWindow.close();

      }

    };

    /*
     * Function that is executed after a state has been removed
     */
    var funcAfterRemove = function(sStateType, sAppName, sStateName) {

      // we only remove the item from the desktop menu
      for (var i = 0; i &lt; me.statesMenu.items.length; i++) {

        if (me.statesMenu.items.getAt(i).text == sStateName) {

          me.statesMenu.remove(me.statesMenu.items.getAt(i));
          break;

        }

      }

    }

    // we create the items of the desktop menu
    ret.items.push(

    {
          text : &#39;Tile&#39;,
          handler : me.tileWindows,
          scope : me,
          iconCls : &quot;toolbar-other-tile&quot;,
          minWindows : 1
        }, {
          text : &#39;Cascade&#39;,
          handler : me.cascadeWindows,
          scope : me,
          iconCls : &quot;toolbar-other-cascade&quot;,
          minWindows : 1
        });

    // we append the items for state management, only if the state
    // management is enabled
    if (GLOBAL.STATE_MANAGEMENT_ENABLED)
      ret.items.push(&#39;-&#39;, {
            text : &quot;Load state&quot;,
            iconCls : &quot;toolbar-other-load&quot;,
            menu : me.statesMenu
          }, {
            text : &quot;Save&quot;,
            iconCls : &quot;dirac-icon-save&quot;,
            handler : Ext.bind(me.SM.oprSaveAppState, me.SM, [&quot;application&quot;, &quot;desktop&quot;, me, funcAfterSave], false),
            minWindows : 1,
            scope : me
          }, {
            text : &quot;Save As ...&quot;,
            iconCls : &quot;dirac-icon-save&quot;,
            handler : Ext.bind(me.SM.formSaveState, me.SM, [&quot;application&quot;, &quot;desktop&quot;, me, funcAfterSave], false),
            minWindows : 1,
            scope : me
          }, {
            text : &quot;Refresh states&quot;,
            iconCls : &quot;toolbar-other-refresh&quot;,
            handler : me.oprRefreshAllDesktopStates,
            scope : me
          }, {
            text : &quot;Manage states ...&quot;,
            iconCls : &quot;toolbar-other-manage&quot;,
            handler : Ext.bind(me.SM.formManageStates, me.SM, [&quot;desktop&quot;, funcAfterRemove], false),
            scope : me
          })

    return ret;
  },

<span id='Ext-dirac-views-desktop-Main-method-oprReadDesktopStatesFromCache'>  /**
</span>   * @private Method called to load the desktop states into the desktop menu
   *          after they&#39;ve been read from the server.
   */
  oprReadDesktopStatesFromCache : function() {

    var me = this;

    me.statesMenu.removeAll();

    // creating items for the states
    var oStates = GLOBAL.APP.SM.getApplicationStates(&quot;application&quot;, &quot;desktop&quot;);// OK

    for (var i = 0, len = oStates.length; i &lt; len; i++) {

      var sStateName = oStates[i];

      var newItem = Ext.create(&#39;Ext.menu.Item&#39;, {
            text : sStateName,
            handler : Ext.bind(me.oprLoadDesktopState, me, [sStateName], false),
            scope : me,
            iconCls : &quot;dirac-icon-state&quot;,
            stateType : &quot;application&quot;,
            minWidth : 200,
            menu : [{
                  text : &quot;Share state&quot;,
                  stateName : sStateName,
                  handler : function() {

                    var oThisItem = this;

                    GLOBAL.APP.SM.oprShareState(&quot;desktop&quot;, oThisItem.stateName, function(rCode, rAppName, rStateName, rMessage) {

                          if (rCode == 1) {

                            var oHtml = &quot;&quot;;
                            oHtml += &quot;&lt;div style=&#39;padding:5px&#39;&gt;The string you can send is as follows:&lt;/div&gt;&quot;;
                            oHtml += &quot;&lt;div style=&#39;padding:5px;font-weight:bold&#39;&gt;&quot; + rMessage + &quot;&lt;/div&gt;&quot;;

                            Ext.MessageBox.alert(&quot;Info for sharing the &lt;span style=&#39;color:red&#39;&gt;&quot; + rStateName + &quot;&lt;/span&gt; state:&quot;, oHtml);

                          }

                        });

                  },
                  iconCls : &quot;dirac-icon-share&quot;
                }, {
                  text : &quot;Make public&quot;,
                  stateName : sStateName,
                  handler : function() {

                    var oThisItem = this;

                    GLOBAL.APP.SM.oprPublishState(&quot;desktop&quot;, oThisItem.stateName);

                  },
                  iconCls : &quot;dirac-icon-share&quot;
                }]
          });

      me.statesMenu.add(newItem);

    }

    me.statesMenu.add(&quot;-&quot;);

    // creating items for the state links
    var oRefs = GLOBAL.APP.SM.getApplicationStates(&quot;reference&quot;, &quot;desktop&quot;);// OK

    for (var i = 0, len = oRefs.length; i &lt; len; i++) {

      var sStateName = oRefs[i];

      var newItem = Ext.create(&#39;Ext.menu.Item&#39;, {
            text : sStateName,
            handler : Ext.bind(me.loadSharedStateByName, me, [&quot;desktop&quot;, sStateName], false),
            scope : me,
            iconCls : &quot;dirac-icon-link&quot;,
            stateType : &quot;reference&quot;,
            minWidth : 200
          });

      me.statesMenu.add(newItem);

    }

  },

<span id='Ext-dirac-views-desktop-Main-method-tileWindows'>  /**
</span>   * Function to tile the windows within the available desktop space
   */
  tileWindows : function() {
    var me = this, availWidth = me.body.getWidth(true);
    var x = me.xTickSize, y = me.yTickSize, nextY = y;

    me.windows.each(function(win) {
          if (win.isVisible() &amp;&amp; !win.maximized) {
            var w = win.el.getWidth();

            // Wrap to next row if we are not at the line
            // start and this Window will
            // go off the end
            if (x &gt; me.xTickSize &amp;&amp; x + w &gt; availWidth) {
              x = me.xTickSize;
              y = nextY;
            }

            win.setPosition(x, y);
            x += w + me.xTickSize;
            nextY = Math.max(nextY, y + win.el.getHeight() + me.yTickSize);
          }
        });
  },

<span id='Ext-dirac-views-desktop-Main-method-cascadeWindows'>  /**
</span>   * Function to arrange the windows in a cascade order
   */
  cascadeWindows : function() {
    var x = 0, y = 0, zmgr = this.getDesktopZIndexManager();

    zmgr.eachBottomUp(function(win) {
          if (win.isWindow &amp;&amp; win.isVisible() &amp;&amp; !win.maximized) {
            win.setPosition(x, y);
            x += 20;
            y += 20;
          }
        });
  },

<span id='Ext-dirac-views-desktop-Main-method-createWindowMenu'>  /**
</span>   * Overridable configuration method for the taskbar window menu (windowMenu)
   * 
   * @return Object
   */
  createWindowMenu : function() {
    var me = this;

    return {
      defaultAlign : &#39;br-tr&#39;,
      items : [{
            text : &#39;Save/Load state&#39;,
            scope : me,
            menu : new Ext.menu.Menu()
          }, &quot;-&quot;, {
            text : &#39;Restore&#39;,
            handler : me.onWindowMenuRestore,
            scope : me
          }, {
            text : &#39;Minimize&#39;,
            handler : me.onWindowMenuMinimize,
            scope : me
          }, {
            text : &#39;Maximize&#39;,
            handler : me.onWindowMenuMaximize,
            scope : me
          }, &#39;-&#39;, {
            text : &#39;Pin&#39;,
            handler : me.onWindowMenuPin,
            scope : me
          }, {
            text : &#39;Show header&#39;,
            handler : me.onWindowMenuHeader,
            scope : me
          }, &#39;-&#39;, {
            text : &#39;Close&#39;,
            handler : me.onWindowMenuClose,
            scope : me
          }],
      listeners : {
        beforeshow : me.onWindowMenuBeforeShow,
        hide : me.onWindowMenuHide,
        scope : me
      }
    };
  },

<span id='Ext-dirac-views-desktop-Main-method-onWindowMenuBeforeShow'>  /**
</span>   * @private Handler called before the window taskbar menu appears. It is used
   *          to disable enable some operations within that menu.
   */
  onWindowMenuBeforeShow : function(menu) {
    var me = this;

    var items = menu.items.items, win = menu.theWin;

    if (win.desktopStickMode) {
      // if the active window is pinned, then restore, minimize,
      // maximize items are disabled
      items[2].setDisabled(true);
      items[3].setDisabled(true);
      items[4].setDisabled(true);

    } else {

      items[2].setDisabled(win.maximized !== true &amp;&amp; win.hidden !== true); // Restore
      items[3].setDisabled(win.minimized === true); // Minimize
      items[4].setDisabled(win.maximized === true || win.hidden === true); // Maximize

    }

    // We copy the menu from the window

    if (win.loadedObjectType == &quot;link&quot;) {

      items[0].hide();
      items[1].hide();

    } else if (win.loadedObjectType == &quot;app&quot;) {

      items[0].show();
      items[1].show();

      items[0].menu = win.loadMenu;
      // setting the Pin/Unpin text
      if (win.desktopStickMode) {

        items[6].setText(&quot;Unpin&quot;);

      } else {

        items[6].setText(&quot;Pin&quot;);

      }

      // setting the Show/Hide header text
      if (win.getHeader().hidden) {

        items[7].setText(&quot;Show header&quot;);

      } else {

        items[7].setText(&quot;Hide header&quot;);

      }

    }
  },

<span id='Ext-dirac-views-desktop-Main-method-onWindowMenuClose'>  /**
</span>   * @private Handler called when the Close option is choicen from the window
   *          taskbar menu
   */
  onWindowMenuClose : function() {
    var me = this, win = me.windowMenu.theWin;
    win.close();
  },

<span id='Ext-dirac-views-desktop-Main-method-onWindowMenuMaximize'>  /**
</span>   * @private Handler called when the Maximize option is choicen from the window
   *          taskbar menu
   */
  onWindowMenuMaximize : function() {
    var me = this, win = me.windowMenu.theWin;
    win.maximize();
  },

<span id='Ext-dirac-views-desktop-Main-method-onWindowMenuMinimize'>  /**
</span>   * @private Handler called when the Minimize option is choicen from the window
   *          taskbar menu
   */
  onWindowMenuMinimize : function() {
    var me = this, win = me.windowMenu.theWin;
    win.minimize();
  },

<span id='Ext-dirac-views-desktop-Main-method-onWindowMenuPin'>  /**
</span>   * @private Handler called when the Pin/Unpin option is choicen from the
   *          window taskbar menu
   */
  onWindowMenuPin : function() {
    var me = this, win = me.windowMenu.theWin;
    var items = me.windowMenu.items.items;

    me.setDesktopStickMode(win);

    if (win.desktopStickMode) {

      items[6].setText(&quot;Unpin&quot;);

    } else {

      items[6].setText(&quot;Pin&quot;);

    }

    me.refreshUrlDesktopState();

  },

<span id='Ext-dirac-views-desktop-Main-method-onWindowMenuHeader'>  /**
</span>   * @private Handler called when the Show/Hide header option is choicen from
   *          the window taskbar menu
   */
  onWindowMenuHeader : function() {
    var me = this, win = me.windowMenu.theWin;
    var items = me.windowMenu.items.items;

    if (win.getHeader().hidden) {

      items[7].setText(&quot;Hide header&quot;);
      win.getHeader().show();

    } else {

      items[7].setText(&quot;Show header&quot;);
      win.getHeader().hide();

    }

    me.refreshUrlDesktopState();

  },

<span id='Ext-dirac-views-desktop-Main-method-onWindowMenuRestore'>  /**
</span>   * @private Handler called when the Restore option is choicen from the window
   *          taskbar menu
   */
  onWindowMenuRestore : function() {
    var me = this, oWin = me.windowMenu.theWin;
    oWin.restore();
    oWin.minimized = false;
    oWin.getHeader().show();
    me.refreshUrlDesktopState();
  },

<span id='Ext-dirac-views-desktop-Main-method-onWindowMenuHide'>  /**
</span>   * @private Handler called when the window taskbar menu gets hidden
   * @param menu
   */
  onWindowMenuHide : function(menu) {

  },

  // ----------------------------------------------------------------------------------------

<span id='Ext-dirac-views-desktop-Main-method-onDesktopMenu'>  /**
</span>   * @private Handler called before the desktop context menu
   * @param e
   */
  onDesktopMenu : function(e) {
    var me = this, menu = me.contextMenu;
    e.stopEvent();
    if (!menu.rendered) {
      menu.on(&#39;beforeshow&#39;, me.onDesktopMenuBeforeShow, me);
    }
    menu.showAt(e.getXY());
    menu.doConstrain();
  },

<span id='Ext-dirac-views-desktop-Main-method-onDesktopMenuBeforeShow'>  /**
</span>   * @private Handler called before the desktop context menu is shown This
   *          function serves to disable or enable some operations that have
   *          minWindows property defined
   * @param menu
   *          This parametear can be used in other menus as well.
   */
  onDesktopMenuBeforeShow : function(menu) {
    var me = this, count = me.windows.getCount();

    menu.items.each(function(item) {
          var min = item.minWindows || 0;
          item.setDisabled(count &lt; min);
        });
  },

<span id='Ext-dirac-views-desktop-Main-method-getWallpaper'>  /**
</span>   * Function to get the wallpaper object
   */
  getWallpaper : function() {
    return this.wallpaper.wallpaper;
  },

<span id='Ext-dirac-views-desktop-Main-method-setWallpaper'>  /**
</span>   * Function to set the wallpaper
   * 
   * @param {String}
   *          wallpaper Physical path to the wallpaper image
   * @param {boolean}
   *          stretch If it is true then the wallpaper will be streched,
   *          otherwise not
   */
  setWallpaper : function(wallpaper, stretch) {
    this.wallpaper.setWallpaper(wallpaper, stretch);
    return this;
  },

<span id='Ext-dirac-views-desktop-Main-method-setTickSize'>  /**
</span>   * @private
   */
  setTickSize : function(xTickSize, yTickSize) {
    var me = this, xt = me.xTickSize = xTickSize, yt = me.yTickSize = (arguments.length &gt; 1) ? yTickSize : xt;

    me.windows.each(function(win) {
          var dd = win.dd, resizer = win.resizer;
          dd.xTickSize = xt;
          dd.yTickSize = yt;
          resizer.widthIncrement = xt;
          resizer.heightIncrement = yt;
        });
  },

  // ------------------------------------------------------
  // Window management methods

<span id='Ext-dirac-views-desktop-Main-method-getActiveWindow'>  /**
</span>   * Function to get the top active window
   * 
   * @return {Ext.window.Window}
   */
  getActiveWindow : function() {
    var win = null, zmgr = this.getDesktopZIndexManager();

    if (zmgr) {
      // We cannot rely on activate/deactive because that
      // fires against non-Window
      // components in the stack.

      zmgr.eachTopDown(function(comp) {
            if (comp.isWindow &amp;&amp; !comp.hidden) {
              win = comp;
              return false;
            }
            return true;
          });
    }

    return win;
  },

<span id='Ext-dirac-views-desktop-Main-method-getDesktopZIndexManager'>  /**
</span>   * @private
   */
  getDesktopZIndexManager : function() {
    var windows = this.windows;
    // TODO - there has to be a better way to get this...
    return (windows.getCount() &amp;&amp; windows.getAt(0).zIndexManager) || null;
  },

<span id='Ext-dirac-views-desktop-Main-method-getWindow'>  getWindow : function(id) {
</span>    return this.windows.get(id);
  },

<span id='Ext-dirac-views-desktop-Main-method-minimizeWindow'>  /**
</span>   * @private Handler called when the window gets minimized
   * @param {Ext.window.Window}
   *          win The window object getting minimized
   */
  minimizeWindow : function(win) {
    win.minimized = true;
    this.refreshUrlDesktopState();
    win.hide();
  },

<span id='Ext-dirac-views-desktop-Main-method-maximizeWindow'>  /**
</span>   * @private Handler called when the window gets maximized
   * @param {Ext.window.Window}
   *          win The window object getting maximized
   */
  maximizeWindow : function(win) {
    win.getHeader().hide();
    win.minimized = false;
    win.toFront();
  },

<span id='Ext-dirac-views-desktop-Main-method-onWindowClose'>  /**
</span>   * @private Handler called when the window gets closed
   * @param {Ext.window.Window}
   *          win The object window getting closed
   */
  onWindowClose : function(win) {
    var me = this;

    if (win.parentWindow)
      win.parentWindow.removeChildWindowFromList(win);

    me.windows.remove(win);
    /*
     * If the number of windows get 0, the current desktop state is cleared
     */
    if (me.windows.getCount() == 0) {

      if (me.currentState != &quot;&quot;)
        GLOBAL.APP.SM.oprRemoveActiveState(&quot;desktop&quot;, me.currentState);// OK

      me.currentState = &#39;&#39;;
      me.refreshUrlDesktopState();
    }
    me.taskbar.removeTaskButton(win.taskButton);
    me.updateDeactiveWindow();

    /*
     * Close all other child windows
     */

    for (var i = win.childWindows.length - 1; i &gt;= 0; i--) {
      if (win.childWindows[i] != null) {
        console.log(win.childWindows[i].title);
        win.childWindows[i].close();
      }
    }

    /*
     * if it is not child window remove the current state out of active states
     */
    if (!win.isChildWindow) {
      if (win.currentState != &quot;&quot;)
        GLOBAL.APP.SM.oprRemoveActiveState(win.loadedObject.self.getName(), win.currentState);// OK

      me.refreshUrlDesktopState();
    }

    /*
     * if the window was pinned we free all the cells taken by the application
     */
    if (win.desktopGridStickButton) {
      if (win.desktopGridStickButton.type == &quot;unpin&quot;) {

        me.setDesktopMatrixCells(win.i_x, win.i_x + win.ic_x - 1, win.i_y, win.i_y + win.ic_y - 1, false);

      }
    }

  },

<span id='Ext-dirac-views-desktop-Main-method-onWindowMove'>  /**
</span>   * @private Handler called when the window gets moved
   * @param {Ext.window.Window}
   *          oWindow The object window getting moved
   * @param {int}
   *          iX The X coordinate of the window
   * @param {int}
   *          iY The Y coordinate of the window
   */
  onWindowMove : function(oWindow, iX, iY, eOpts) {

    var me = this;

    // if the window is in the pinned state
    if (oWindow.desktopStickMode) {

      // if the mouse is within the constraints of the window
      // header
      if ((GLOBAL.MOUSE_X &gt;= oWindow.x) &amp;&amp; (GLOBAL.MOUSE_X &lt;= oWindow.x + oWindow.getWidth()) &amp;&amp; (GLOBAL.MOUSE_Y &gt;= oWindow.y) &amp;&amp; (GLOBAL.MOUSE_Y &lt;= oWindow.y + oWindow.getHeader().getHeight())) {

        // we calculate the distance of the mouse cursor
        // regarding X and Y axes
        var oXDiff = GLOBAL.MOUSE_X - iX;
        var oYDiff = GLOBAL.MOUSE_Y - iY;

        var oBox = me.getBoxSize();

        // calculation of the new X and Y coordinates of the
        // cursor
        var oNewX = iX + oXDiff % oBox[0];
        var oNewY = iY + oYDiff % oBox[1];

        // geting the cell where the new cursor coordinates lay
        var oCell = me.getGridCell(oNewX, oNewY, false);

        /*
         * we check whether the cells needed by the app starting from the oCell,
         * are not taken
         */
        var bOK = true;

        if ((oCell[0] + oWindow.ic_x - 1 &gt;= me.desktopGranularity[0]) || (oCell[1] + oWindow.ic_y - 1 &gt;= me.desktopGranularity[1])) {
          bOK = false;
        } else {

          for (var i = oCell[0]; i &lt;= oCell[0] + oWindow.ic_x - 1; i++) {
            for (var j = oCell[1]; j &lt;= oCell[1] + oWindow.ic_y - 1; j++) {

              if (!((i &gt;= oWindow.i_x) &amp;&amp; (i &lt;= oWindow.i_x + oWindow.ic_x - 1) &amp;&amp; (j &gt;= oWindow.i_y) &amp;&amp; (j &lt;= oWindow.i_y + oWindow.ic_y - 1))) {

                if (me.takenCells[j][i]) {

                  bOK = false;
                  break;

                }
              }
            }

            if (!bOK)
              break;

          }

        }

        // if the destination cells are free i.e. not taken
        if (bOK) {

          // we free the previous cells
          me.setDesktopMatrixCells(oWindow.i_x, oWindow.i_x + oWindow.ic_x - 1, oWindow.i_y, oWindow.i_y + oWindow.ic_y - 1, false);

          // we occupy the new cells of the new position
          me.setDesktopMatrixCells(oCell[0], oCell[0] + oWindow.ic_x - 1, oCell[1], oCell[1] + oWindow.ic_y - 1, true);

          // we change the indexes of the top left cell taken
          // by the app
          oWindow.i_x = oCell[0];
          oWindow.i_y = oCell[1];

          // we record the coordinates of the application
          oWindow._x = Math.round(oWindow.i_x * oBox[0]);
          oWindow._y = Math.round(oWindow.i_y * oBox[1]);

        }

        // we apply the coordinates
        oWindow.suspendEvents(false);
        oWindow.setPosition(oWindow._x, oWindow._y);
        oWindow.resumeEvents();

      }
    }

    me.refreshUrlDesktopState();

  },

<span id='Ext-dirac-views-desktop-Main-method-onWindowResize'>  /**
</span>   * @private Handler called when the window gets resized
   * @param {Ext.window.Window}
   *          win The object window getting resized
   * @param {int}
   *          iWidth The new width of the window
   * @param {int}
   *          iHeight The new height of the window
   */
  onWindowResize : function(oWindow, iWidth, iHeight, eOpts) {

    var me = this;

    // if the window is in the pinned state
    if (oWindow.desktopStickMode) {

      oWindow.suspendEvents(false);
      var oBox = me.getBoxSize();

      var iPomX = oWindow.x + iWidth - 10;
      var iPomY = oWindow.y + iHeight - 10;

      // getting the indexes of the bottom right cell
      var oCell = me.getGridCell(iPomX, iPomY, true);

      /*
       * we check whether the cells needed by the app starting from the
       * [i_x,i_y], are not taken
       */
      var bOK = true;
      for (var i = oWindow.i_x; i &lt;= oCell[0]; i++) {
        for (var j = oWindow.i_y; j &lt;= oCell[1]; j++) {

          if (!((i &gt;= oWindow.i_x) &amp;&amp; (i &lt;= oWindow.i_x + oWindow.ic_x - 1) &amp;&amp; (j &gt;= oWindow.i_y) &amp;&amp; (j &lt;= oWindow.i_y + oWindow.ic_y - 1))) {

            if (me.takenCells[j][i]) {

              bOK = false;
              break;

            }
          }
        }

        if (!bOK)
          break;

      }

      // if the destination cells are free i.e. not taken
      if (bOK) {

        // we free the previous cells
        me.setDesktopMatrixCells(oWindow.i_x, oWindow.i_x + oWindow.ic_x - 1, oWindow.i_y, oWindow.i_y + oWindow.ic_y - 1, false);

        // we occupy the new cells of the new position
        me.setDesktopMatrixCells(oWindow.i_x, oCell[0], oWindow.i_y, oCell[1], true);

        // we set up the new cell dimensions of the window
        oWindow.ic_x = oCell[0] - oWindow.i_x + 1;
        oWindow.ic_y = oCell[1] - oWindow.i_y + 1;

      }

      // we are setting the new dimensions of the window
      oWindow.setWidth(Math.round(oWindow.ic_x * oBox[0]));
      oWindow.setHeight(Math.round(oWindow.ic_y * oBox[1]));

      oWindow.resumeEvents();

    }

    me.refreshUrlDesktopState();
  },

<span id='Ext-dirac-views-desktop-Main-method-printTakenCellsMatrix'>  /**
</span>   * @private Method to print the matrix of the desktop cells
   * @param {String}
   *          sWhere Some label that will refer to the place where this function
   *          was called
   */
  printTakenCellsMatrix : function(sWhere) {

    var me = this;

    console.log(sWhere);

    var s = &quot;&quot;;

    for (var i = 0; i &lt; me.desktopGranularity[0]; i++) {

      for (var j = 0; j &lt; me.desktopGranularity[1]; j++) {

        s += &quot; &quot; + ((me.takenCells[i][j]) ? 1 : 0) + &quot; &quot;;

      }
      s += &#39;\n&#39;;

    }

    console.log(s);

  },

<span id='Ext-dirac-views-desktop-Main-method-getGridCell'>  /**
</span>   * Function to get the indexes of the underlying cell in the desktop cell
   * matrix regarding the cursor position (iX,iY)
   */
  getGridCell : function(iX, iY, bWithFixNearestBorder) {

    var me = this;

    var oBox = me.getBoxSize();

    var iBoxWidth = oBox[0];
    var iBoxHeight = oBox[1];

    var iXAxis = Math.floor(iX / iBoxWidth);
    var iYAxis = Math.floor(iY / iBoxHeight);

    if (bWithFixNearestBorder) {

      var oResidualX = iX % iBoxWidth;

      if (oResidualX &lt; (iBoxWidth / 2))
        iXAxis--;

      var oResidualY = iY % iBoxHeight;

      if (oResidualY &lt; (iBoxHeight / 2))
        iYAxis--;

    }

    if (iXAxis &gt;= me.desktopGranularity[1]) {
      iXAxis = me.desktopGranularity[1] - 1;
    } else if (iXAxis &lt; 0) {

      iXAxis = 0;

    }

    if (iYAxis &gt;= me.desktopGranularity[0]) {
      iYAxis = me.desktopGranularity[0] - 1;
    } else if (iYAxis &lt; 0) {

      iYAxis = 0;

    }

    return [iXAxis, iYAxis];

  },

<span id='Ext-dirac-views-desktop-Main-method-findEmptyGridCell'>  /**
</span>   * Function to find an empty area into the desktop cell matrix with dimensions
   * iXSize, iYSize
   * 
   * @param {int}
   *          iXSize Number of cells regarding the X axis
   * @param {int}
   *          iYSize Number of cells regarding the Y axis
   */
  findEmptyGridCell : function(iXSize, iYSize) {

    var me = this;
    var oFound = false;
    var oPosI = [-1, -1];

    for (var i = 0; i &lt;= me.desktopGranularity[1] - iXSize; i++) {
      for (var j = 0; j &lt;= me.desktopGranularity[0] - iYSize; j++) {

        var bFree = true;

        for (var k1 = i; k1 &lt; i + iXSize; k1++) {
          for (var k2 = j; k2 &lt; j + iYSize; k2++) {

            if (me.takenCells[k2][k1]) {

              bFree = false;
              break;

            }

          }
        }

        if (bFree) {

          oPosI[0] = i;
          oPosI[1] = j;
          oFound = true;
          break;

        }

      }

      if (oFound)
        break;
    }

    return oPosI;

  },

<span id='Ext-dirac-views-desktop-Main-method-setDesktopStickMode'>  /**
</span>   * Function to activate/deactivate the pinning state of a window
   * 
   * @param {Ext.dirac.core.Window}
   *          oWin The window object
   */
  setDesktopStickMode : function(oWin) {

    var me = this;

    oWin.desktopStickMode = !oWin.desktopStickMode;

    if (oWin.desktopStickMode) {

      // First try to locate on the same place as before
      var oLocatedAsPrev = false;
      var oFindEmptyCell = [-1, -1];
      var oDim = [2, 2];

      if (oWin.i_x != -1) {

        var bAreAllFree = true;

        for (var i = oWin.i_x; i &lt;= oWin.i_x + oWin.ic_x - 1; i++) {
          for (var j = oWin.i_y; j &lt;= oWin.i_y + oWin.ic_y - 1; j++) {
            if (me.takenCells[j][i]) {
              bAreAllFree = false;
              break;

            }
          }

          if (!bAreAllFree)
            break;

        }

        if (bAreAllFree) {

          oFindEmptyCell = [oWin.i_x, oWin.i_y];
          oDim = [oWin.ic_x, oWin.ic_y];
          oLocatedAsPrev = true;

        }

      }

      if (!oLocatedAsPrev) {

        oFindEmptyCell = me.findEmptyGridCell(oDim[0], oDim[1]);

        if (oFindEmptyCell[0] == -1) {
          oDim = [1, 1];
          oFindEmptyCell = me.findEmptyGridCell(oDim[0], oDim[1]);
        }

      }

      if (oFindEmptyCell[0] &gt;= 0) {

        var oPos = [0, 0];
        var oBox = me.getBoxSize();

        oPos[0] = Math.round(oFindEmptyCell[0] * oBox[0]);
        oPos[1] = Math.round(oFindEmptyCell[1] * oBox[1]);

        oWin._before_pin_state = {
          x : oWin.x,
          y : oWin.y,
          width : oWin.getWidth(),
          height : oWin.getHeight(),
          maximized : oWin.maximized,
          minimized : oWin.minimized
        };

        oWin._x = oPos[0];
        oWin._y = oPos[1];
        oWin.i_x = oFindEmptyCell[0];
        oWin.i_y = oFindEmptyCell[1];
        oWin.ic_x = oDim[0];
        oWin.ic_y = oDim[1];

        me.setDesktopMatrixCells(oWin.i_x, oWin.i_x + oWin.ic_x - 1, oWin.i_y, oWin.i_y + oWin.ic_y - 1, true);

        oWin.suspendEvents(false);

        oWin.restore();
        oWin.toFront();
        oWin.minimized = false;

        oWin.setPosition(oPos[0], oPos[1]);
        oWin.setSize(Math.round(oBox[0] * oDim[0]), Math.round(oBox[1] * oDim[1]));
        oWin.resumeEvents();
        oWin.desktopGridStickButton.setType(&quot;unpin&quot;);

        oWin.getHeader().show();

        /*
         * Hide minimize, maximize, restore
         */

        oWin.tools[3].hide();
        oWin.tools[4].hide();
        oWin.tools[5].hide();
        oWin.taskButton.setIconCls(&quot;system_pin_window&quot;);

      } else {

        GLOBAL.APP.CF.alert(&quot;No available space on the desktop can be found !&quot;, &quot;warning&quot;);
        oWin.desktopStickMode = false;

      }

    } else {

      me.setDesktopMatrixCells(oWin.i_x, oWin.i_x + oWin.ic_x - 1, oWin.i_y, oWin.i_y + oWin.ic_y - 1, false);

      /*
       * Show minimize, maximize, restore
       */
      oWin.tools[3].show();
      oWin.tools[4].show();
      oWin.tools[5].show();

      oWin.loadWindowFrameState(oWin._before_pin_state);

      oWin.desktopGridStickButton.setType(&quot;pin&quot;);

      oWin.taskButton.setIconCls(&quot;notepad&quot;);

    }

    me.refreshUrlDesktopState();
  },

<span id='Ext-dirac-views-desktop-Main-method-setDesktopMatrixCells'>  /**
</span>   * Function to set/unset the cells of particular region of the desktop cells
   * matrix
   * 
   * 
   * @param {int}
   *          iXMin Starting X index
   * @param {int}
   *          iXMax Ending X index
   * @param {int}
   *          iYMin Starting Y index
   * @param {int}
   *          iYMax Ending Y index
   * @param {boolean}
   *          bSetValue The setter value
   * 
   */
  setDesktopMatrixCells : function(iXMin, iXMax, iYMin, iYMax, bSetValue) {

    var me = this;

    for (var i = iXMin; i &lt;= iXMax; i++) {
      for (var j = iYMin; j &lt;= iYMax; j++) {
        me.takenCells[j][i] = bSetValue;
      }
    }

  },

<span id='Ext-dirac-views-desktop-Main-method-createWindow'>  /**
</span>   * Function to create a window and to load the module defined by the
   * moduleName
   * 
   * @param {String}
   *          loadedObjectType The type of the object to be loaded [app|link]
   * @param {String}
   *          moduleName The name of the module (the JavaScript class) to be
   *          loaded
   * @param {String}
   *          setupData Data needed by the app during loading process
   * 
   */
  createWindow : function(loadedObjectType, moduleName, setupData) {

    Ext.get(&quot;app-dirac-loading&quot;).show();

    if (loadedObjectType == &quot;app&quot;) {

      var oParts = moduleName.split(&quot;.&quot;);
      var sStartClass = &quot;&quot;;

      if (oParts.length == 2)
        sStartClass = moduleName + &quot;.classes.&quot; + oParts[1];
      else
        sStartClass = moduleName;

      // if the development mod is off, we set up diffrent path to
      // load javascript
      if (GLOBAL.DEV == 0) {

        var oConfig = {
          enabled : true,
          paths : {}
        };

        oConfig[&quot;paths&quot;][oParts[0] + &quot;.&quot; + oParts[1] + &quot;.classes&quot;] = &quot;static/&quot; + oParts[0] + &quot;/&quot; + oParts[1] + &quot;/build&quot;;

        Ext.Loader.setConfig(oConfig);

      }

      Ext.require(sStartClass, function() {

            var me = this;

            // creating an object of the demeanded application
            var instance = Ext.create(sStartClass, {
                  launcherElements : {
                    title : &#39;Module&#39;,
                    iconCls : &#39;notepad&#39;,
                    applicationName : oParts[1],
                    width : 0,
                    height : 0,
                    maximized : true,
                    x : null,
                    y : null
                  }
                });

            var config = {
              desktop : me,
              setupData : setupData,
              loadedObject : instance,
              loadedObjectType : &quot;app&quot;
            };

            // initializing window
            var window = me.initWindow(config);

            // showing window
            window.show();

          }, this);

    } else if (loadedObjectType == &quot;link&quot;) {
      var me = this;

      var window = me.initWindow({
            setupData : setupData,
            loadedObjectType : &quot;link&quot;,
            linkToLoad : moduleName
          });

      // showing window
      window.show();

    }

  },

<span id='Ext-dirac-views-desktop-Main-method-initWindow'>  /**
</span>   * Function that is used by modules to create windows with some content. This
   * function does configuration of the window object.
   * 
   * @param {Object}
   *          config Configuration and content of the window
   */

  initWindow : function(config) {

    var me = this, win, cfg = Ext.applyIf(config || {}, {
          stateful : false,
          isWindow : true,
          constrainHeader : false,
          minimizable : true,
          maximizable : true,
          animCollapse : false,
          border : false,
          hideMode : &#39;offsets&#39;,
          layout : &#39;fit&#39;,
          x : 0,
          y : 0
        });

    // creating the window
    win = me.add(new Ext.dirac.views.desktop.Window(cfg));

    // we add the window to the windows collections
    me.windows.add(win);

    // adding taskbar button related to the window
    win.taskButton = me.taskbar.addTaskButton(win);

    // setting event handlers for some events of the window
    win.on({
          activate : me.updateActiveWindow,
          beforeshow : me.updateDeactiveWindow,
          afterrender : me.hideMessageBox,
          deactivate : me.updateDeactiveWindow,
          minimize : me.minimizeWindow,
          maximize : me.maximizeWindow,
          destroy : me.onWindowClose,
          move : me.onWindowMove,
          resize : me.onWindowResize,
          scope : me
        });

    win.on({
          boxready : function() {
            win.dd.xTickSize = me.xTickSize;
            win.dd.yTickSize = me.yTickSize;

            if (win.resizer) {
              win.resizer.widthIncrement = me.xTickSize;
              win.resizer.heightIncrement = me.yTickSize;
            }
          },
          single : true
        });

    // replace normal window close
    win.doClose = function() {
      win.el.disableShadow();
      win.destroy();
      win.doClose = Ext.emptyFn;
    };

    return win;
  },

<span id='Ext-dirac-views-desktop-Main-method-hideMessageBox'>  hideMessageBox : function() {
</span>    Ext.get(&quot;app-dirac-loading&quot;).hide();
  },

<span id='Ext-dirac-views-desktop-Main-method-updateDeactiveWindow'>  /**
</span>   * @private Function to update the active window
   */
  updateDeactiveWindow : function() {
    var me = this, activeWindow = me.getActiveWindow(), last = me.lastActiveWindow;
    if (activeWindow === last) {
      return;
    }

    if (last) {
      if (last.el.dom) {
        last.addCls(me.inactiveWindowCls);
        last.removeCls(me.activeWindowCls);
      }
      last.active = false;
    }

    me.lastActiveWindow = activeWindow;

    if (activeWindow) {
      activeWindow.addCls(me.activeWindowCls);
      activeWindow.removeCls(me.inactiveWindowCls);
      activeWindow.minimized = false;
      activeWindow.active = true;
    }

    me.taskbar.setActiveButton(activeWindow &amp;&amp; activeWindow.taskButton);

  },

<span id='Ext-dirac-views-desktop-Main-method-updateActiveWindow'>  updateActiveWindow : function() {
</span>    var me = this, activeWindow = me.getActiveWindow(), last = me.lastActiveWindow;
    if (activeWindow === last) {
      return;
    }

    if (last) {
      if (last.el.dom) {
        last.addCls(me.inactiveWindowCls);
        last.removeCls(me.activeWindowCls);
      }
      last.active = false;
    }

    me.lastActiveWindow = activeWindow;

    if (activeWindow) {
      activeWindow.addCls(me.activeWindowCls);
      activeWindow.removeCls(me.inactiveWindowCls);
      activeWindow.minimized = false;
      activeWindow.active = true;
    }

    me.taskbar.setActiveButton(activeWindow &amp;&amp; activeWindow.taskButton);

  },

  /*
   * BROADCAST METHODS FOR THE ACTIVE WINDOWS
   */

<span id='Ext-dirac-views-desktop-Main-method-addStateToExistingWindows'>  /**
</span>   * Function to add new state to the instances of the same module
   * 
   * @param {String}
   *          stateName This is the name od the state
   * @param {String}
   *          appName Name of the module
   * @param {Object}
   *          stateData Data of the module that define its state
   */
  addStateToExistingWindows : function(stateType, stateName, appName) {

    var me = this;

    me.windows.each(function(item, index, len) {
          if (item.getAppClassName() == appName)
            item.addNewState(stateType, stateName);
        });

    if (appName in me.registerStartMenus)
      me.registerStartMenus[appName].addNewState(stateType, stateName);

  },

<span id='Ext-dirac-views-desktop-Main-method-oprRefreshAllAppStates'>  /**
</span>   * Function used to refresh the states of a certain module (application) and
   * to update all instances of the module that are active at the moment
   * 
   * @param {String}
   *          appName Name of the module (application)
   */
  oprRefreshAllAppStates : function(appName) {

    var me = this;

    /*
     * If the Ajax is not successful then the states will remain the same
     */

    var oFunc = function(iCode, sAppName) {
      if (iCode == 1) {
        me.windows.each(function(item, index, len) {
              if (item.getAppClassName() == appName)
                item.oprRefreshAppStates();
            });

        if (appName in me.registerStartMenus)
          me.registerStartMenus[appName].oprRefreshAppStates();
      }

    }

    GLOBAL.APP.SM.oprReadApplicationStatesAndReferences(appName, oFunc);

  },

<span id='Ext-dirac-views-desktop-Main-method-removeStateFromWindows'>  /**
</span>   * Function to remove a state from the state lists of the instances of the
   * same module
   * 
   * @param {String}
   *          stateName Name of the state
   * @param {String}
   *          appName Name of the module (application)
   */
  removeStateFromWindows : function(sStateType, sAppName, sStateName) {

    var me = this;

    me.windows.each(function(item, index, len) {
          if (item.getAppClassName() == sAppName)
            item.removeState(sStateType, sStateName);
        });

    if (sAppName in me.registerStartMenus)
      me.registerStartMenus[sAppName].removeState(sStateType, sStateName);

  },

<span id='Ext-dirac-views-desktop-Main-method-oprLoadDesktopState'>  /**
</span>   * Function to load a desktop state
   * 
   * @param {String}
   *          stateName The name of the state
   */
  oprLoadDesktopState : function(sStateName) {

    /*
     * First we have to check whether some other state is currently in use so we
     * have to give possibility to choose whether they want to continue to the
     * chosen state or not
     */

    var me = this;

    var iCount = me.windows.getCount();

    if (iCount &gt; 0) {

      if (me.currentState == &#39;&#39;) {

        /*
         * There is no active desktop state
         */

        var ret = Ext.MessageBox.confirm(&#39;Confirm&#39;, &#39;Are you sure you want to close windows without saving them ?&#39;, function(button) {

              var me = this;
              if (button === &#39;yes&#39;) {

                me.closeAllActiveWindows();

                me.__loadDesktopStateData(sStateName);

              }
            }, me);

      } else {

        /*
         * There is an active desktop state
         */

        var ret = Ext.MessageBox.confirm(&#39;Confirm&#39;, &#39;There is an active desktop state. Do you want to save the state before we load the new one ?&#39;, function(button) {

              var me = this;
              if (button === &#39;yes&#39;) {

                var funcAfterSave = function(sAppName, sStateNameOld) {
                };

                me.SM.oprSaveAppState(&quot;application&quot;, &quot;desktop&quot;, me, funcAfterSave);
              }

              me.closeAllActiveWindows();
              me.__loadDesktopStateData(sStateName);

            }, me);

      }
    } else {

      // if there are no windows open
      me.__loadDesktopStateData(sStateName);

    }

  },

<span id='Ext-dirac-views-desktop-Main-method-__loadDesktopStateData'>  /**
</span>   * Function to create all windows from a desktop state
   * 
   * @param {String}
   *          stateName The name of the state
   */
  __loadDesktopStateData : function(sStateName) {

    var me = this;

    var iStateLoaded = GLOBAL.APP.SM.isStateLoaded(&quot;application&quot;, &quot;desktop&quot;, sStateName);

    switch (iStateLoaded) {
      case -1 :
        GLOBAL.APP.CF.alert(&quot;The state does not exist !&quot;, &quot;warning&quot;);
        return;
        break;
      case -2 :
        me.funcPostponedLoading = function() {

          me.__loadDesktopStateData(sStateName);

        }

        setTimeout(me.funcPostponedLoading, 1000);
        return;
        break;
    }

    me.loadState(GLOBAL.APP.SM.getStateData(&quot;application&quot;, &quot;desktop&quot;, sStateName));

    if (me.currentState != &quot;&quot;)
      GLOBAL.APP.SM.oprRemoveActiveState(&quot;desktop&quot;, me.currentState);// OK

    me.currentState = sStateName;
    GLOBAL.APP.SM.oprAddActiveState(&quot;desktop&quot;, sStateName);// OK

    me.refreshUrlDesktopState();

  },

<span id='Ext-dirac-views-desktop-Main-method-closeAllActiveWindows'>  /**
</span>   * Function to close all active windows
   */
  closeAllActiveWindows : function() {

    var me = this;

    me.windows.each(function(win) {

          win.close();

        });

  },

<span id='Ext-dirac-views-desktop-Main-method-oprRefreshAllDesktopStates'>  /**
</span>   * Function to refresh the list of desktop states
   */
  oprRefreshAllDesktopStates : function() {

    var me = this;

    var oFunc = function(iCode, sAppName) {

      if (iCode == 1) {
        me.oprReadDesktopStatesFromCache();
      }

    }

    GLOBAL.APP.SM.oprReadApplicationStatesAndReferences(&quot;desktop&quot;, oFunc);

  },

<span id='Ext-dirac-views-desktop-Main-method-addDesktopReference'>  /**
</span>   * Function to add new desktop link to the menu
   */
  addDesktopReference : function(stateName) {

    var me = this;

    var newItem = Ext.create(&#39;Ext.menu.Item&#39;, {
          text : stateName,
          handler : Ext.bind(me.loadSharedStateByName, me, [&quot;desktop&quot;, stateName], false),
          scope : me,
          iconCls : &quot;dirac-icon-link&quot;
        });

    me.statesMenu.add(newItem);

  },

<span id='Ext-dirac-views-desktop-Main-method-removeDesktopReference'>  /**
</span>   * Function to remove desktop link out of the menu
   */
  removeDesktopReference : function() {

    var me = this;

    for (var i = me.statesMenu.items.length - 1; i &gt;= 0; i--) {

      if (me.statesMenu.items.getAt(i).self.getName() == &quot;Ext.menu.Separator&quot;)
        break;

      if (me.statesMenu.items.getAt(i).text == stateName) {

        me.statesMenu.remove(me.menu.items.getAt(i));
        break;

      }

    }

  },

  /*
   * END: MANAGEMENT OF DESKTOP STATES
   */

<span id='Ext-dirac-views-desktop-Main-method-refreshUrlDesktopState'>  /**
</span>   * Function to refresh the state of the desktop working area in the URL
   */
  refreshUrlDesktopState : function() {

    var me = this;

    var sNewUrlState = &quot;&quot;;

    var sThemeText = &quot;Grey&quot;;

    if (GLOBAL.WEB_THEME == &quot;ext-all-neptune&quot;)
      sThemeText = &quot;Neptune&quot;;

    if (GLOBAL.WEB_THEME == &quot;ext-all&quot;)
      sThemeText = &quot;Classic&quot;;

    if (me.currentState != &quot;&quot;) {

      // if there is an active desktop state
      me._state_related_url = &quot;url_state=1|&quot; + me.currentState;
      sNewUrlState = &quot;?view=&quot; + GLOBAL.VIEW_ID + &quot;&amp;theme=&quot; + sThemeText + &quot;&amp;url_state=1|&quot; + me.currentState;

    } else {

      // if there is NO active desktop state
      for (var i = 0; i &lt; me.windows.getCount(); i++) {
        var oWin = me.windows.getAt(i);

        if ((oWin != undefined) &amp;&amp; (oWin != null) &amp;&amp; (!oWin.isChildWindow))
          sNewUrlState += ((sNewUrlState == &quot;&quot;) ? &quot;&quot; : &quot;^&quot;) + oWin.getUrlDescription();
      }

      me._state_related_url = &quot;url_state=0|&quot; + sNewUrlState;
      sNewUrlState = &quot;?view=&quot; + GLOBAL.VIEW_ID + &quot;&amp;theme=&quot; + sThemeText + &quot;&amp;url_state=0|&quot; + sNewUrlState;

    }

    var oHref = location.href;
    var oQPosition = oHref.indexOf(&quot;?&quot;);

    if (oQPosition != -1) {

      sNewUrlState = oHref.substr(0, oQPosition) + sNewUrlState;

    } else {

      sNewUrlState = oHref + sNewUrlState;

    }

    window.history.pushState(&quot;X&quot;, &quot;ExtTop - Desktop Sample App&quot;, sNewUrlState);

  },

<span id='Ext-dirac-views-desktop-Main-method-loadSharedStateByName'>  loadSharedStateByName : function(sAppName, sStateName) {
</span>
    var me = this;

    var oData = GLOBAL.APP.SM.getStateData(&quot;reference&quot;, sAppName, sStateName);
    GLOBAL.APP.SM.oprLoadSharedState(oData[&quot;link&quot;], me.cbAfterLoadSharedState);

  },

<span id='Ext-dirac-views-desktop-Main-method-registerStartAppMenu'>  /**
</span>   * Function to register the submenu of an application within the main menu
   */
  registerStartAppMenu : function(oMenu, sAppClassName) {

    var me = this;
    me.registerStartMenus[sAppClassName] = oMenu;

  },

<span id='Ext-dirac-views-desktop-Main-method-getViewMainDimensions'>  /**
</span>   * Function to get the dimensions of the desktop
   */
  getViewMainDimensions : function() {

    var me = this;

    return [me.getWidth(), me.getHeight() - GLOBAL.APP.MAIN_VIEW.taskbar.getHeight()];

  },

<span id='Ext-dirac-views-desktop-Main-method-getBoxSize'>  /**
</span>   * Function to get the dimensions of a desktop cell
   */
  getBoxSize : function() {

    var me = this;

    return [me.boxSizeX, me.boxSizeY];

  },

<span id='Ext-dirac-views-desktop-Main-method-createNewModuleContainer'>  createNewModuleContainer : function(oData) {
</span>
    var me = this;

    me.createWindow(oData.objectType, oData.moduleName, oData.setupData);

  },

<span id='Ext-dirac-views-desktop-Main-method-cbAfterLoadSharedState'>  /*-----------------IMPLEMENTATION OF THE INTERFACE BETWEEN STATE MANAGEMENT ADN DESKTOP----------------*/
</span>
  cbAfterLoadSharedState : function(iCode, sLink, oDataReceived) {

    var me = GLOBAL.APP.MAIN_VIEW;

    var oDataItems = sLink.split(&quot;|&quot;);

    if (oDataItems[0] != &quot;desktop&quot;) {

      var oSetupData = {
        &quot;data&quot; : oDataReceived,
        &quot;currentState&quot; : &quot;&quot;
      };

      me.createWindow(&quot;app&quot;, oDataItems[0], oSetupData);

    } else {

      for (var i = 0, len = oDataReceived[&quot;data&quot;].length; i &lt; len; i++) {

        var appStateData = oDataReceived[&quot;data&quot;][i];
        var loadedObjectType = ((!appStateData.loadedObjectType) ? &quot;app&quot; : appStateData.loadedObjectType); // TODO
        // We
        // can
        // remove
        // it
        // later.
        var name = appStateData.module

        if (name)
          me.createWindow(loadedObjectType, name, appStateData);

      }

      if (me.currentState != &quot;&quot;)
        GLOBAL.APP.SM.oprRemoveActiveState(&quot;desktop&quot;, me.currentState);

      me.currentState = &quot;&quot;;

    }

  },

<span id='Ext-dirac-views-desktop-Main-method-cbAfterSaveSharedState'>  cbAfterSaveSharedState : function(iCode, sLinkName, sLink) {
</span>
    var me = GLOBAL.APP.MAIN_VIEW;

    var oDataItems = sLink.split(&quot;|&quot;);

    if (oDataItems[0] != &quot;desktop&quot;) {
      me.addStateToExistingWindows(&quot;reference&quot;, sLinkName, oDataItems[0]);
    } else {
      me.addDesktopReference(sLinkName);
    }

  },
<span id='Ext-dirac-views-desktop-Main-method-createHelpWindow'>  createHelpWindow : function(loadedObjectType, moduleName, setupData, win) {
</span>
    var me = this;
    Ext.get(&quot;app-dirac-loading&quot;).show();

    var oParts = moduleName.split(&quot;.&quot;);
    var sStartClass = &quot;&quot;;

    if (oParts.length == 2)
      sStartClass = moduleName + &quot;.classes.&quot; + oParts[1];
    else
      sStartClass = moduleName;

    // if the development mod is off, we set up diffrent path to
    // load javascript
    if (GLOBAL.DEV == 0) {

      var oConfig = {
        enabled : true,
        paths : {}
      };

      oConfig[&quot;paths&quot;][oParts[0] + &quot;.&quot; + oParts[1] + &quot;.classes&quot;] = &quot;static/&quot; + oParts[0] + &quot;/&quot; + oParts[1] + &quot;/build&quot;;

      Ext.Loader.setConfig(oConfig);

    }

    Ext.require(sStartClass, function() {

      var me = this;

      // creating an object of the demeanded application
      var instance = Ext.create(sStartClass, {
            renderTo : Ext.getBody(),
            layout : &#39;fit&#39;,
            launcherElements : {
              title : &#39;Module&#39;,
              applicationName : oParts[1],
              width : 0,
              height : 0,
              maximized : true,
              x : null,
              y : null
            }
          });

      instance.loadState(setupData);
      win.add(instance);
        // initializing window

      }, this);

    Ext.get(&quot;app-dirac-loading&quot;).hide();
  }
    /*-----------------END - IMPLEMENTATION OF THE INTERFACE BETWEEN STATE MANAGEMENT ADN DESKTOP----------------*/

  });
</pre>
</body>
</html>
